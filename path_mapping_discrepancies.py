from rich.console import Console
import json
from utils import generate_random_string, compare_two_responses_using_hashing, cprint, cprint_json, cprint_panel
from authentication_handler import AuthenticationHandler
import requests
import urllib.parse


class PathMappingDiscrepancies:
    def __init__(self, endpoint, auth=False, auth_conf_file=None):
        self.console = Console()

        self.endpoint = endpoint

        self.auth = auth
        if self.auth:
            self.auth_conf_file = auth_conf_file
            if self.auth_conf_file:
                with open(self.auth_conf_file) as auth_conf:
                    json_auth_conf = json.loads(auth_conf.read())
                    self.auth_type = json_auth_conf['auth_type']
                    self.auth_data = json_auth_conf['auth_data']
                self.authentication_handler = AuthenticationHandler(self.auth_type, **self.auth_data)
            else:
                cprint(self, 'Authentication configuration is missing. Exiting...', 'failure')
                exit()
        else:
            cprint(self, 'Authentication is not enabled. Exiting...', 'failure')
            exit()

        self.auth_prepared_request = None

        self.allowed_methods = ['GET', 'POST']

        self.base_request_responses = {}
        self.added_path_segment_responses = {}
        self.potential_vulnerable_endpoints = {}

        self.extensions = []

        self.potential_vulnerable_endpoints_responses = {}

        self.summary = {}

    def get_auth_prepared_request(self):
        self.auth_prepared_request = self.authentication_handler.authenticate()

    def get_base_request(self):
        session = requests.Session()
        prepared_request = self.auth_prepared_request

        for method in self.allowed_methods:
            prepared_request.method = method
            prepared_request.url = self.endpoint
            response = session.send(prepared_request)

            self.base_request_responses[method] = response

    @staticmethod
    def add_cache_buster(request):
        cache_buster = generate_random_string()

        if urllib.parse.urlparse(request.url).query:
            request.url += '&' + cache_buster + '=ma4747gh'
        else:
            request.url += '?' + cache_buster + '=ma4747gh'

        headers = request.headers
        headers['Origin'] = 'https://{}.com'.format(cache_buster)
        headers['Via'] = cache_buster
        request.headers = headers

    def add_arbitrary_path_segment(self):
        session = requests.Session()
        prepared_request = self.auth_prepared_request

        for method in self.allowed_methods:
            random_string = generate_random_string()

            endpoint = urllib.parse.urlparse(self.endpoint)
            new_path = endpoint.path + '/' + random_string
            new_endpoint = urllib.parse.urlunparse(
                (
                    endpoint.scheme,
                    endpoint.netloc,
                    new_path,
                    endpoint.params,
                    endpoint.query,
                    endpoint.fragment
                )
            )

            prepared_request.method = method
            prepared_request.url = new_endpoint
            self.add_cache_buster(prepared_request)
            response = session.send(prepared_request)

            self.added_path_segment_responses[method] = response

    def detect_potential_vulnerability(self):
        for method in self.allowed_methods:
            response_one = self.base_request_responses[method]
            response_two = self.added_path_segment_responses[method]
            potential_vulnerability = compare_two_responses_using_hashing(response_one, response_two)

            if potential_vulnerability:
                self.potential_vulnerable_endpoints[method] = self.endpoint
                cprint(self, 'The endpoint \'{}\' using the \'{}\' method may be vulnerable.'.format(self.endpoint, method), 'info')

        if not self.potential_vulnerable_endpoints:
            cprint(self, 'No potential vulnerabilities found. Exiting...', 'failure')
            exit()

    def load_extensions(self):
        with open('extensions.txt') as extensions_file:
            for line in extensions_file.readlines()[:5]:
                self.extensions.append(line.strip())

    def brute_force_static_extensions(self):
        session = requests.Session()
        prepared_request = self.auth_prepared_request

        self.load_extensions()

        for method in self.allowed_methods:
            self.potential_vulnerable_endpoints_responses[method] = {}
            for extension in self.extensions:
                random_string = generate_random_string()

                endpoint = urllib.parse.urlparse(self.endpoint)
                new_path = endpoint.path + '/' + random_string + '.' + extension
                new_endpoint = urllib.parse.urlunparse(
                    (
                        endpoint.scheme,
                        endpoint.netloc,
                        new_path,
                        endpoint.params,
                        endpoint.query,
                        endpoint.fragment
                    )
                )

                prepared_request.method = method
                prepared_request.url = new_endpoint
                self.add_cache_buster(prepared_request)
                response = session.send(prepared_request)

                self.potential_vulnerable_endpoints_responses[method][extension] = [response, prepared_request.url]

    @staticmethod
    def check_if_the_response_get_cached_using_x_cache_header(response):
        headers = response.headers
        if 'X-Cache' in headers:
            if headers['X-Cache'] == 'miss':
                return True

    def evaluate_potential_vulnerable_endpoints(self):
        self.summary[self.endpoint] = {
            'vulnerable': False,
            'vulnerabilities': {}
        }

        for method, responses in self.potential_vulnerable_endpoints_responses.items():
            for extension, value in responses.items():
                if self.check_if_the_response_get_cached_using_x_cache_header(value[0]):
                    if method in self.summary[self.endpoint]['vulnerabilities']:
                        pass
                    else:
                        self.summary[self.endpoint]['vulnerabilities'][method] = []
                    self.summary[self.endpoint]['vulnerabilities'][method].append({'vulnerable_extension': extension, 'payload': value[1]})

                    cprint(self, 'The endpoint \'{}\', when accessed using the \'{}\' method and \'{}\' extension, is likely vulnerable.'.format(self.endpoint, method, extension), 'success')
                    cprint(self, 'Used Payload: {}'.format(value[1]), 'info')

        if self.summary[self.endpoint]['vulnerabilities']:
            self.summary[self.endpoint]['vulnerable'] = True

        cprint(self, 'Summary:', 'ack')
        cprint_json(self, data=self.summary, highlighted=False)

    def generate_poc(self):
        if not self.summary[self.endpoint]['vulnerable']:
            return
        vulnerabilities = self.summary[self.endpoint]["vulnerabilities"]
        poc_url = (
            vulnerabilities.get("GET", [])[0]["payload"] if "GET" in vulnerabilities and vulnerabilities["GET"] else
            vulnerabilities.get("POST", [])[0]["payload"] if "POST" in vulnerabilities and vulnerabilities["POST"] else
            None
        )

        proof_of_concept = '''PoC

1. Configure a proxy in your browser (e.g., using \'Burp Suite\').

2. Open the following URL: \'{}\'. You\'ll observe that the response contains an \'X-Cache\' header with the value \'miss\'.

3. Revisit the same URL. This time, you\'ll observe that the response contains an \'X-Cache\' header with the value \'hit\', indicating that this sensitive dynamic endpoint has been cached.'''.format(poc_url)
        cprint_panel(self, mode=0, data=proof_of_concept.encode())

    def start(self):
        self.get_auth_prepared_request()
        self.get_base_request()
        self.add_arbitrary_path_segment()
        self.detect_potential_vulnerability()
        self.brute_force_static_extensions()
        self.evaluate_potential_vulnerable_endpoints()
        self.generate_poc()
