import requests
from requests.auth import HTTPBasicAuth


class AuthenticationHandler:
    def __init__(self, auth_type, **kwargs):
        """
        Initializes the AuthenticationHandler with a specific authentication type and keyword arguments.

        :param auth_type: The type of authentication to use (e.g., 'basic', 'token', 'api_key', etc.).
        :param kwargs: Additional arguments such as credentials, headers, or request options.
        """
        self.auth_type = auth_type.lower()  # Normalize the authentication type to lowercase
        self.kwargs = kwargs  # Store additional keyword arguments

        # Validate the provided authentication type
        if self.auth_type not in ['basic', 'token', 'oauth2', 'api_key', 'cookies', 'explicit']:
            raise ValueError(f'Unsupported authentication type: {self.auth_type}')

    def authenticate(self):
        """
        Authenticates based on the provided authentication type and returns a prepared request.

        :return: Prepared HTTP request object.
        """
        # Basic Authentication using username and password
        if self.auth_type == 'basic':
            auth = HTTPBasicAuth(self.kwargs['username'], self.kwargs['password'])  # Create HTTP Basic Auth object
            request_kwargs = self.kwargs.get('request_kwargs', {})  # Fetch any extra request options

            # Create and prepare the request
            request = requests.Request(url='https://ma4747gh', auth=auth, **request_kwargs)
            return request.prepare()

        # Token-based Authentication (Bearer Token or OAuth2)
        elif self.auth_type in ['token', 'oauth2']:
            headers = self.kwargs.get('headers', {})  # Fetch existing headers or create an empty one
            headers['Authorization'] = f'Bearer {self.kwargs["token"]}'  # Add the token to Authorization header
            request_kwargs = self.kwargs.get('request_kwargs', {})  # Fetch any extra request options

            # Create and prepare the request
            request = requests.Request(url='https://ma4747gh', headers=headers, **request_kwargs)
            return request.prepare()

        # API Key Authentication
        elif self.auth_type == 'api_key':
            request_type = self.kwargs['type']  # Type of API key authentication: header or query parameter
            request_kwargs = self.kwargs.get('request_kwargs', {})  # Fetch any extra request options

            # API key passed in headers
            if request_type == 'header':
                headers = self.kwargs.get('headers', {})
                headers[self.kwargs['header_name']] = f'Bearer {self.kwargs["token"]}'  # Add API key to header

                # Create and prepare the request
                request = requests.Request(url='https://ma4747gh', headers=headers, **request_kwargs)
                return request.prepare()

            # API key passed as a query parameter
            elif request_type == 'query_parameter':
                method = self.kwargs['method']  # HTTP method: GET or POST

                # GET method with query parameters
                if method == 'GET':
                    params = self.kwargs['params']  # Query parameters
                    request = requests.Request(url='https://ma4747gh', params=params, **request_kwargs)
                    return request.prepare()

                # POST method with form data
                elif method == 'POST':
                    data = self.kwargs['data']  # POST data
                    request = requests.Request(url='https://ma4747gh', data=data, **request_kwargs)
                    return request.prepare()

                else:
                    raise ValueError(f'Unsupported method type: {method}')

            else:
                raise ValueError(f'Unsupported api_key authentication type: {request_type}')

        # Cookie-based Authentication
        elif self.auth_type == 'cookies':
            cookies = self.kwargs['cookies']  # Fetch cookies for authentication
            request_kwargs = self.kwargs.get('request_kwargs', {})  # Fetch any extra request options

            # Create and prepare the request
            request = requests.Request(url='https://ma4747gh', cookies=cookies, **request_kwargs)
            return request.prepare()

        # Explicit login-based Authentication (e.g., via form submission)
        elif self.auth_type == 'explicit':
            login_method = self.kwargs['login_method']  # HTTP method for login (GET or POST)
            login_url = self.kwargs['login_url']  # Login URL
            auth_request_kwargs = self.kwargs.get('auth_request_kwargs', {})  # Options for login request
            request_kwargs = self.kwargs.get('request_kwargs', {})  # Options for subsequent requests

            # Perform a GET request for login
            if login_method == 'GET':
                params = self.kwargs['params']  # Login parameters
                response = requests.get(login_url, params=params, allow_redirects=False, **auth_request_kwargs)

                # Use cookies from login response to make subsequent requests
                request = requests.Request(url='https://ma4747gh', cookies=response.cookies, **request_kwargs)
                return request.prepare()

            # Perform a POST request for login
            elif login_method == 'POST':
                data = self.kwargs['data']  # Login form data
                response = requests.post(login_url, data=data, allow_redirects=False, **auth_request_kwargs)

                # Use cookies from login response to make subsequent requests
                request = requests.Request(url='https://ma4747gh', cookies=dict(response.cookies), **request_kwargs)
                return request.prepare()

            else:
                raise ValueError(f'Unsupported login method type: {login_method}')

            # TODO
            # Ensure the success or failure of the login attempt is properly validated, without making assumptions.

        # TODO
        # digest
        # mtls
        # saml

        else:
            raise ValueError(f'Unsupported authentication type: {self.auth_type}')
